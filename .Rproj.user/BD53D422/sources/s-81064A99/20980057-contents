#' @importFrom dplyr mutate case_when arrange desc inner_join filter id pull distinct bind_rows group_by summarise rename select setdiff rowwise ungroup slice summarise_all
#' @importFrom DT datatable formatStyle styleEqual
#' @importFrom ggiraph geom_bar_interactive geom_col_interactive renderGirafe girafe girafeOutput geom_jitter_interactive
#' @importFrom ggplot2 ggplot aes position_dodge geom_label scale_fill_manual theme element_blank theme_bw element_line element_text element_rect labs coord_flip guides facet_wrap geom_rect geom_text coord_polar geom_boxplot position_jitter ylim alpha scale_alpha_manual position_stack
#' @importFrom IDEATools importIDEA MakeTrees exportIDEA dimensionsPlots radarPlots
#' @importFrom openxlsx createWorkbook createStyle addWorksheet writeData setColWidths conditionalFormatting saveWorkbook
#' @importFrom readr parse_number
#' @importFrom rmarkdown render
#' @importFrom shiny renderUI fileInput p reactive validate need eventReactive observeEvent HTML icon div br fluidRow renderPlot plotOutput imageOutput renderImage withProgress hr tableOutput em renderTable downloadHandler incProgress
#' @importFrom shinycssloaders withSpinner
#' @importFrom shinydashboard box renderValueBox valueBox renderInfoBox infoBox valueBoxOutput infoBoxOutput
#' @importFrom shinyWidgets sendSweetAlert awesomeRadio
#' @importFrom stats quantile
#' @importFrom stringr str_to_title str_replace_all str_detect str_split str_remove_all
#' @importFrom ggimage geom_image
#' @importFrom tidyr gather spread
#' @importFrom utils zip
app_server <- function(input, output,session) {
  
  # Pour l'affichage de graphiques dans l'application
  options(shiny.usecairo = TRUE)
  options(shiny.useragg = TRUE)  
  
  # On augmente la taille max autorisée pour les imports
  options(shiny.maxRequestSize = 30 * 1024^2)

  # On désactive les warnings pour alléger les logs
  options(warn=-1)
  
  # Par défaut, les onglets d'analyse sont cachés tant que les CGU ne sont pas acceptés
  hideTab(inputId = "navar", target = "tab1")
  hideTab(inputId = "navar", target = "tab2")

  # Permet d'éviter une erreur liée au fichier "Rplots.pdf"
  pdf(NULL)
  
  # Définition du dossier de travail temporaire où créer puis piocher les fichiers
  outdir <- tempdir()
  

  ## Définition des deux modules d'imports, qui ne s'affichent que si les CGU sont validées
  output$file <- renderUI({
    
    if(input$CGU) {
      fileInput("files", "Charger un calculateur", accept = c(".xls",".xlsx",".json"), width = "90%", multiple = FALSE, buttonLabel = "Charger...",placeholder = "Aucun fichier chargé")
    } else {p("Merci d'accepter les CGU avant de continuer.")}
  })
  
  # Si les CGU ne sont pas cochés, alors les fonctionnalités sont cachées
  observeEvent(input$CGU,{
    
  if(input$CGU){
      showTab(inputId = "navar", target = "tab1")
      showTab(inputId = "navar", target = "tab2")
  } else {
    hideTab(inputId = "navar", target = "tab1")
    hideTab(inputId = "navar", target = "tab2")
    
  }
      
  })
    
  output$dir<- renderUI({
    
    if(input$CGU) {
      fileInput("dir", "Charger plusieurs calculateurs", accept = c(".xls",".xlsx",".json"), width = "90%", multiple = TRUE, buttonLabel = "Charger...",placeholder = "Maintenir la touche CTRL pour une sélection multiple")
    } else {p("Merci d'accepter les CGU avant de continuer.")}
  })
  

  ## Définition des deux boutons de renvoi vers les analyses, qui n'apparaissent que si les CGU sont validées
  output$gotoindiv <- renderUI({
    
    if(input$CGU) {
      actionButton("go_to_indiv", label = "Commencer une analyse individuelle", width = "100%", icon = icon("user"))
    } else {NULL}
    
    
  })
  
  observeEvent(input$go_to_indiv,{
    updateTabsetPanel(session,"navar","indiv")
  })


  output$gotocollec<- renderUI({
    if(input$CGU) {
      actionButton("go_to_collec", label = "Commencer une analyse de groupe", width = "100%",icon = icon("users"))
    } else {NULL}
  })

  observeEvent(input$go_to_collec,{
    updateTabsetPanel(session,"navar","collec")
    
  })

  
  # Petite sécurité
  userFile <- reactive({
    # If no file is selected, don't do anything
    validate(need(input$files, message = FALSE))
    input$files
  })


  # Création des 2 jeux de données, selon si l'import est individuel ou collectif
  IDEAdata <- eventReactive(input$files,{
    importIDEA(input = input$files$datapath, anonymous = FALSE)
  })


  IDEAcollectiveData <- eventReactive(input$dir,{
    importIDEA(input = dirname(input$dir$datapath[[1]]), anonymous = FALSE)
  })
  
  ###### UI TRIGGER ANALYSE DE INDIVIDUELLE #########

  observeEvent(input$files, {

    # Petit texte aidant à la navigation après l'import
    output$helper1 <- renderUI({
      HTML("<p style='color:blue'> NB : Pour aller plus loin dans le détail des indicateurs et pour exporter ces résultats, vous pouvez naviguer dans le menu d'en-tête 'Analyse individuelle'.</p>")
    }) 

    # Boite contenant la synthèse des métadonnées de l'exploitation
    output$metadata <- renderUI({
      
      meta <- IDEAdata()$metadata
      
      list_meta <- list()
      
      for(i in c("MTD_01","MTD_02","MTD_06","MTD_11","MTD_13")) {
        
        ligne <- subset(MTD_legende,code == i)
        
        if(i == "MTD_02" & !is.na(meta[i])) {meta[i] = paste0(round(as.numeric(meta[i]))," ha")}
        
        list_meta[[i]] <- paste0("<li>",ligne$nom,": ",ifelse(is.na(meta[i]) | meta[i] == "0"| meta[i] == 0, yes = "Inconnue", no = meta[i]),"</li>")
        
      }
      
      
      box(title =HTML("<b>Métadonnées de l'exploitation</b>"),
          HTML(paste0("<h4><ul>",list_meta,"</ul></h4>")),
          width = 12)
      
    })
    

    #### Définition des valueBoxs dimension
    output$note_IDEA <- renderValueBox({
      value <- min(IDEAdata()$dataset$dimension_value)
      valueBox(paste0(value,"/100"), subtitle = "Note IDEA", icon = icon("tachometer"), color = "purple")
    })

    output$note_ae <- renderValueBox({
      value <- unique(subset(IDEAdata()$dataset, dimension == "Agroécologique")$dimension_value)
      valueBox(paste0(value,"/100"), subtitle = "Durabilité Agroécologique", icon = icon("leaf"), color = "green")
      
    })

    output$note_st <- renderValueBox({
      value <- unique(subset(IDEAdata()$dataset, dimension == "Socio-Territoriale")$dimension_value)
      valueBox(paste0(value,"/100"), subtitle = "Durabilité Socio-Territoriale", icon = icon("handshake"), color = "blue")
    })

    output$note_ec <- renderValueBox({
      value <- unique(subset(IDEAdata()$dataset, dimension == "Economique")$dimension_value)  
      valueBox(paste0(value,"/100"), subtitle = "Durabilité Economique", icon = icon("euro-sign"), color = "orange")
    })
    
    #### Définition des infobox propriétés
    output$prop1 <- renderInfoBox({
      
      val <- IDEAdata()$nodes$Robustesse$Robustesse
      
      color <- replace_col(val)
      
      val <- str_to_title(val)
      
      ico <- ifelse(val %in% c("Favorable", "Très Favorable"), yes = "smile", no = "frown")
      
      box1 <- infoBox(value = paste(val),
                      title = "Robustesse",
                      icon = icon(ico),
                      color = color, width = 2, href = "#")
      
      box1
      
    })

    output$prop2 <- renderInfoBox({
      
      val <- IDEAdata()$nodes$Autonomie$Autonomie
      
      color <- replace_col(val)
      
      val <- str_to_title(val)
      
      ico <- ifelse(val %in% c("Favorable", "Très Favorable"), yes = "smile", no = "frown")
      
      box2 <- infoBox(value = paste(val),
                      title = "Autonomie",
                      icon = icon(ico),
                      color = color, width = 2, href = "#")

      box2
      
    })
    output$prop3 <- renderInfoBox({
      
      
      val <- IDEAdata()$nodes$Capacité$`Capacité productive et reproductive de biens et de services`
      
      color <- replace_col(val)
      
      val <- str_to_title(val)
      
      ico <- ifelse(val %in% c("Favorable", "Très Favorable"), yes = "smile", no = "frown")
      
      box3 <- infoBox(value = paste(val),
                      title = "Capacité productive et reproductive de biens et de services",
                      icon = icon(ico),
                      color = color, width = 2, href = "#")

      box3
      
      
    })
    output$prop4 <- renderInfoBox({
      
      val <- IDEAdata()$nodes$Responsabilité$`Responsabilité globale`
      
      color <- replace_col(val)
      
      val <- str_to_title(val)
      
      ico <- ifelse(val %in% c("Favorable", "Très Favorable"), yes = "smile", no = "frown")
      
      box4 <- infoBox(value = paste(val),
                      title = "Reponsabilité Globale",
                      icon = icon(ico),
                      color = color, width = 2, href = "#")
      
      box4
      
      
    })
    output$prop5 <- renderInfoBox({
      
      val <- IDEAdata()$nodes$Ancrage$`Ancrage territorial`
      
      color <- replace_col(val)
      
      val <- str_to_title(val)
      
      ico <- ifelse(val %in% c("Favorable", "Très Favorable"), yes = "smile", no = "frown")
      
      box5 <- infoBox(value = paste(val),
                      title = "Ancrage territorial",
                      icon = icon(ico),
                      color = color, width = 2, href = "#")

      box5
      
    })


    # Compilation des différentes info/valueBoxes en une boite de synthèse
    output$synthesis <- renderUI({
      box(width = 12,title = HTML("<b> Synthèse des résultats </b>"),collapsible = FALSE,
          div(style="display:inline-block;width:100%;text-align: center;",valueBoxOutput("note_IDEA", width = 12)),
          HTML("<br>"),
          valueBoxOutput("note_ae", width = 4),
          valueBoxOutput("note_st", width = 4),
          valueBoxOutput("note_ec", width = 4),
          br(),
          fluidRow(),
          infoBoxOutput("prop1", width = 6),
          infoBoxOutput("prop2", width = 6),
          infoBoxOutput("prop5", width = 6),
          infoBoxOutput("prop4", width = 6),
          infoBoxOutput("prop3", width = 12),
      )
      
      
    })
    
    # Onglet de détail des indicateurs, composé d'un tabPanel avec (1) composantes et (2) les indicateurs
    output$analyse_indic <- renderUI({
      tabsetPanel(
        # Panneau des composantes, avec une sortie dynamique + un téléchagement du graphe polarisé
        tabPanel("Analyse des composantes",
                 br(),
                 HTML("<center>Les composantes correspondent à des regroupements (sommes) des 53 indicateurs. Elles offrent un cadre de lecture intermédiaire entre les indicateurs et les dimensions.</center>"),
                 br(),
                 uiOutput("compo")
        ),
        # Panneau du détail des indicateurs, avec différentes options de personnalisation
        tabPanel("Analyse des indicateurs",
                 sidebarLayout(
                   sidebarPanel(
                     selectInput(
                       inputId = "choose_indics",
                       label = "Dimension ou propriété à afficher", 
                       choices = list(
                         Dimensions = c("Dimension Agroécologique"="Agroécologique","Dimension Socio-Territoriale"= "Socio-Territoriale","Dimension Economique"="Economique"),
                         Propriétés = c("Robustesse","Autonomie", "Ancrage Territorial", "Capacité Productive et reproductive de biens et de services"="Capacité productive et reproductive \nde biens et de services","Responsabilité Globale"="Responsabilité globale"))
                     ),
                     radioButtons("choose_graph_type","Choisir le type de représentation",
                                  choices = c("Diagramme en barres" = "barres", "Diagramme en barres polarisé (= radar)" = "pie"), selected = "barres"),
                     radioButtons("choose_percent","Exprimer les scores en...",
                                  choices = c("Valeur absolue" ="no","Pourcentage %" = "yes"), selected = "no")
                   ), mainPanel(
                     girafeOutput("plot_indics", width = "100%", height = "500px"),
                     HTML("<br> <center> Note : L'intitulé complet de chaque indicateur s'affiche au survol de la partie correspondante du graphique.</center>"),)
                   
                   
                 )
        )
      )
    })
    

    # Définition du graphique des composantes
    output$plot_compo <- renderPlot({
      
      dimensionP <- dimensionsPlots(IDEAdata())
      
      p <- dimensionP[[1]][[2]]$data
      
      g <- ggplot(p, aes(x = composante, y = composante_value)) +
        geom_bar(aes(x = composante, y = max_compo, fill = dimension), alpha = 0.3, color = "black", position = position_dodge(width = 0.8), stat = "identity") +
        geom_col(color = "black", aes(fill = dimension)) +
        geom_label(aes(label = paste0(composante_value,"/",max_compo)), size = 5) +
        scale_fill_manual(values = c("Agroécologique" = "#2e9c15", "Socio-Territoriale" = "#5077FE", "Economique" = "#FE962B")) +
        theme(axis.line = element_blank()) +
        theme_bw() +
        theme(panel.grid.major.x  = element_line(color = "grey90"),
              panel.grid.major.y = element_blank()) +
        theme(panel.grid.minor.x = element_line(color = "grey90"),
              panel.grid.minor.y = element_blank()) +
        theme(
          axis.title.y = element_blank(),
          legend.text = element_text(size = 15),
          legend.title = element_text(size = 17),
          strip.text = element_text(size = 9, face = "bold")
        ) +
        theme(strip.background = element_rect(fill = "white", color = "black")) +
        theme(axis.text = element_text(size = 17, color = "black"), axis.title = element_text(size = 17, face = "bold")) +
        labs(fill = "Dimension", y = "Valeur de la composante / valeur max") +
        theme(legend.position = "bottom") +
        coord_flip()  +
        theme(text = element_text(family = "Roboto"))
      
      g
      
    })

    # Définition du bouton de téléchargement du graphe polarisé
    output$download_polarised <- renderUI({
    
      downloadButton("dl_pol", "(Expérimental) : Télécharger une version polarisée de ce graphique", style = "width: 100%; padding:8px; font-size:120%; background-color: #FDCE93") 
    
    })

    # Définition de la boite affichant les composantes (avec téléchargement de la version polarisée)
    output$compo <- renderUI({
      
      box(width = 12, align = "center",
          uiOutput("download_polarised"),
          br(),
          plotOutput("plot_compo", width = "100%", height = "600px")
          )
      
    })
    
    
    # Création du graphe interactif (ggiraph) des indicateurs qui est re-rendu selon le choix de filtre, de représentation et de valeur
    output$plot_indics <- renderGirafe({
      
      # create common data
      
      common <- IDEAdata()$dataset %>%
        mutate(Propriete = case_when(
          indicateur %in% indicateurs_proprietes$indicateurs_ancrage ~ "Ancrage Territorial",
          indicateur %in% indicateurs_proprietes$indicateurs_autonomie ~ "Autonomie",
          indicateur %in% indicateurs_proprietes$indicateurs_robustesse ~ "Robustesse",
          indicateur %in% indicateurs_proprietes$indicateurs_responsabilite ~ "Responsabilité globale",
          indicateur %in% indicateurs_proprietes$indicateurs_capacite ~ "Capacité productive et reproductive \nde biens et de services"
        )) %>%
        mutate(num_indic = parse_number(indicateur)) %>%
        arrange(desc(dimension), num_indic) %>%
        inner_join(list_max, by = "indicateur") %>% inner_join(list_max_compo, by = "composante") %>%
        mutate(score_ind = round(value / valeur_max * 100, 0)) %>%
        mutate(indicateur = factor(indicateur, levels = unique(indicateur))) %>% 
        mutate(nom_complet_indic = paste0(indicateur," - ", nom_indicateur))
      
      
      
      ## Si c'est une dimension :
      
      if(input$choose_indics %in% c("Agroécologique","Socio-Territoriale","Economique")) {
        
       p <- common %>% filter(dimension == input$choose_indics) %>% 
          arrange(desc(indicateur)) %>% 
          mutate(indicateur = factor(indicateur, levels = unique(indicateur))) %>% 
          mutate(composante = factor(composante, levels = list_max_compo$composante))
        
        
        # Get the name and the y position of each label
        label_data <- p
        label_data$id <- seq(1, nrow(label_data))
        number_of_bar <- nrow(label_data)
        angle <- 90 - 360 * (label_data$id - 0.5) / number_of_bar 
        label_data$hjust <- ifelse(angle < -90, 1, 0)
        label_data$angle <- ifelse(angle < -90, angle + 180, angle)
        
        
        
        
        ## Soit un diagramme en barre 
        if(input$choose_graph_type == "barres") {
          
          
          
          ## Si percent
          if(input$choose_percent == "yes") {
            
            g <- ggplot(p, aes(x = indicateur, y = score_ind, tooltip = nom_complet_indic)) +
              geom_bar_interactive(aes(x = indicateur, y = 100, fill = dimension), alpha = 0.3, color = "black", position = position_dodge(width = 0.8), stat = "identity") +
              geom_col_interactive(color = "black", aes(fill = dimension)) +
              geom_label(aes(label = paste0(score_ind,"%")), size = 5) +
              scale_fill_manual(values = c("Agroécologique" = "#2e9c15", "Socio-Territoriale" = "#5077FE", "Economique" = "#FE962B")) +
              theme(axis.line = element_blank()) +
              theme_bw() +
              theme(panel.grid.major.x  = element_line(color = "grey90"),
                    panel.grid.major.y = element_blank()) +
              theme(panel.grid.minor.x = element_line(color = "grey90"),
                    panel.grid.minor.y = element_blank()) +
              theme(
                axis.title.y = element_blank(),
                legend.text = element_text(size = 15),
                legend.title = element_text(size = 17),
                strip.text = element_text(size = 20, face = "bold")
              ) +
              theme(strip.background = element_rect(fill = "white", color = "black")) +
              theme(axis.text = element_text(size = 18, color = "black"), axis.title = element_text(size = 17, face = "bold")) +
              theme(axis.title = element_blank())+
              labs(fill = "Dimension", y = "Valeur de la composante / valeur max") +
              theme(legend.position = "bottom") +
              coord_flip() +
              guides(fill = FALSE) +
              theme(text = element_text(family = "Roboto")) +
              facet_wrap(~composante, ncol = 2, scales = "free") 
            
            
          } else {
            
            ## Si pas percent
            g <- ggplot(p, aes(x = reorder(indicateur,indicateur), y = value, tooltip = nom_complet_indic)) +
              geom_bar_interactive(aes(x = indicateur, y = valeur_max, fill = dimension), alpha = 0.3, color = "black", position = position_dodge(width = 0.8), stat = "identity") +
              geom_col_interactive(color = "black", aes(fill = dimension)) +
              geom_label(aes(label = paste0(value,"/",valeur_max)), size = 5) +
              scale_fill_manual(values = c("Agroécologique" = "#2e9c15", "Socio-Territoriale" = "#5077FE", "Economique" = "#FE962B")) +
              theme(axis.line = element_blank()) +
              theme_bw() +
              theme(panel.grid.major.x  = element_line(color = "grey90"),
                    panel.grid.major.y = element_blank()) +
              theme(panel.grid.minor.x = element_line(color = "grey90"),
                    panel.grid.minor.y = element_blank()) +
              theme(
                axis.title.y = element_blank(),
                legend.text = element_text(size = 15),
                legend.title = element_text(size = 17),
                strip.text = element_text(size = 20, face = "bold")
              ) +
              theme(strip.background = element_rect(fill = "white", color = "black")) +
              theme(axis.text = element_text(size = 18, color = "black"), axis.title = element_text(size = 17, face = "bold")) +
              theme(axis.title = element_blank())+
              labs(fill = "Dimension", y = "Valeur de la composante / valeur max") +
              theme(legend.position = "bottom") +
              coord_flip() +
              guides(fill = FALSE) +
              theme(text = element_text(family = "Roboto")) +
              facet_wrap(~composante, ncol = 2, scales = "free")
            
            
            
          }
          
          
          ## Sinon, c'est un radar
        } else {
          
          
          ## Si percent
          if(input$choose_percent == "yes") {
            
            
            label_data$position = ifelse(label_data$score_ind > 90, yes = label_data$score_ind - 5, no = label_data$score_ind + 1)
            
            
            g <- ggplot(p, aes(x = indicateur, y = score_ind, tooltip = nom_complet_indic)) +
              geom_rect(xmin = -Inf, ymin = -20, xmax = Inf, ymax = Inf, fill = "white", color = "white") +
              geom_bar_interactive(aes(x = indicateur, y = 100, fill = dimension), alpha = 0.3, color = "black", position = position_dodge(width = 0.8), stat = "identity") +
              geom_col_interactive(color = "black", aes(fill = dimension)) +
              theme_bw() +
              geom_text(data = label_data, aes(x = id, y = position, label = paste0(round(score_ind), "%"), hjust = hjust), color = "black", fontface = "bold", alpha = 1, size = 5, angle = label_data$angle, inherit.aes = FALSE) +
              scale_fill_manual(limits = c("Agroécologique", "Socio-Territoriale", "Economique"), values = c("Agroécologique" = "#2e9c15", "Socio-Territoriale" = "#5077FE", "Economique" = "#FE962B")) +
              theme(
                axis.title = element_blank(),
                plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
                legend.text = element_text(size = 18),
                legend.title = element_text(size = 18),
                axis.text.y = element_blank(),
                axis.ticks.y = element_blank(),
                panel.grid.major.y = element_blank()
              ) +
              theme(axis.text = element_text(size = 18, color = "black", face = "bold")) +
              labs(fill = "Dimension") +
              theme(legend.position = "top") +
              theme(text = element_text(family = "Roboto")) +
              coord_polar()
            
            
            
          } else {
            
            
            label_data$position = ifelse(label_data$score_ind > 90, yes = label_data$value - 0.5, no = label_data$value + 0.5)
            
            
            g <- ggplot(p, aes(x = indicateur, y = value, tooltip = nom_complet_indic)) +
              geom_rect(xmin = -Inf, ymin = -20, xmax = Inf, ymax = Inf, fill = "white", color = "white") +
              geom_bar_interactive(aes(x = indicateur, y = valeur_max, fill = dimension), alpha = 0.3, color = "black", position = position_dodge(width = 0.8), stat = "identity") +
              geom_col_interactive(color = "black", aes(fill = dimension)) +
              theme_bw() +
              geom_text(data = label_data, aes(x = id, y = position, label = paste0(value, "/",valeur_max), hjust = hjust), color = "black", fontface = "bold", alpha = 1, size = 5, angle = label_data$angle, inherit.aes = FALSE) +
              scale_fill_manual(limits = c("Agroécologique", "Socio-Territoriale", "Economique"), values = c("Agroécologique" = "#2e9c15", "Socio-Territoriale" = "#5077FE", "Economique" = "#FE962B")) +
              theme(
                axis.title = element_blank(),
                plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
                legend.text = element_text(size = 18),
                legend.title = element_text(size = 18),
                axis.text.y = element_blank(),
                axis.ticks.y = element_blank(),
                panel.grid.major.y = element_blank()
              ) +
              theme(axis.text = element_text(size = 18, color = "black", face = "bold")) +
              labs(fill = "Dimension") +
              theme(legend.position = "top") +
              theme(text = element_text(family = "Roboto")) +
              coord_polar()
            
          }
          
          
          
        }
        
        girafe(ggobj = g, width_svg = 20, height_svg = 10)
        
        
        
        
        ## Sinon, c'est une propriété :
        
        
      } else {
        
        
        
        filtering <- dplyr::case_when(input$choose_indics == "Ancrage Territorial" ~ "indicateurs_ancrage",
                                      input$choose_indics == "Autonomie" ~ "indicateurs_autonomie",
                                      input$choose_indics == "Robustesse" ~ "indicateurs_robustesse",
                                      input$choose_indics == "Responsabilité globale" ~ "indicateurs_responsabilite",
                                      input$choose_indics == "Capacité productive et reproductive \nde biens et de services" ~ "indicateurs_capacite")
        
        
        prop_name <- indicateurs_proprietes[[filtering]]
        
        
        
        p <- common %>% filter(indicateur %in% prop_name) %>% 
          arrange(desc(indicateur)) %>% 
          mutate(indicateur = factor(indicateur, levels = unique(indicateur))) 
        
        
        
        
        # Get the name and the y position of each label
        label_data <- p
        label_data$id <- seq(1, nrow(label_data))
        number_of_bar <- nrow(label_data)
        angle <- 90 - 360 * (label_data$id - 0.5) / number_of_bar 
        label_data$hjust <- ifelse(angle < -90, 1, 0)
        label_data$angle <- ifelse(angle < -90, angle + 180, angle)
        
        ## Soit un diagramme en barre 
        if(input$choose_graph_type == "barres") {
          
          ## Si percent
          if(input$choose_percent == "yes") {
            
            g <- ggplot(p, aes(x = indicateur, y = score_ind, tooltip = nom_complet_indic)) +
              geom_bar_interactive(aes(x = indicateur, y = 100, fill = dimension), alpha = 0.3, color = "black", position = position_dodge(width = 0.8), stat = "identity") +
              geom_col_interactive(color = "black", aes(fill = dimension)) +
              geom_label(aes(label = paste0(score_ind,"%")), size = 5) +
              scale_fill_manual(values = c("Agroécologique" = "#2e9c15", "Socio-Territoriale" = "#5077FE", "Economique" = "#FE962B")) +
              theme(axis.line = element_blank()) +
              theme_bw() +
              theme(panel.grid.major.x  = element_line(color = "grey90"),
                    panel.grid.major.y = element_blank()) +
              theme(panel.grid.minor.x = element_line(color = "grey90"),
                    panel.grid.minor.y = element_blank()) +
              theme(
                axis.title.y = element_blank(),
                legend.text = element_text(size = 18),
                legend.title = element_text(size = 18),
                strip.text = element_text(size = 18, face = "bold")
              ) +
              theme(strip.background = element_rect(fill = "white", color = "black")) +
              theme(axis.text = element_text(size = 18, color = "black"), axis.title = element_text(size = 17, face = "bold")) +
              theme(axis.title = element_blank())+
              labs(fill = "Dimension", y = "Valeur de la composante / valeur max") +
              theme(legend.position = "bottom") +
              theme(text = element_text(family = "Roboto")) +
              coord_flip() 
            
            
          } else {
            
            ## Si pas percent
            g <- ggplot(p, aes(x = indicateur, y = value, tooltip = nom_complet_indic)) +
              geom_bar_interactive(aes(x = indicateur, y = valeur_max, fill = dimension), alpha = 0.3, color = "black", position = position_dodge(width = 0.8), stat = "identity") +
              geom_col_interactive(color = "black", aes(fill = dimension)) +
              geom_label(aes(label = paste0(value,"/",valeur_max)), size = 5) +
              scale_fill_manual(values = c("Agroécologique" = "#2e9c15", "Socio-Territoriale" = "#5077FE", "Economique" = "#FE962B")) +
              theme(axis.line = element_blank()) +
              theme_bw() +
              theme(panel.grid.major.x  = element_line(color = "grey90"),
                    panel.grid.major.y = element_blank()) +
              theme(panel.grid.minor.x = element_line(color = "grey90"),
                    panel.grid.minor.y = element_blank()) +
              theme(
                axis.title.y = element_blank(),
                legend.text = element_text(size = 18),
                legend.title = element_text(size = 18),
                strip.text = element_text(size = 18, face = "bold")
              ) +
              theme(strip.background = element_rect(fill = "white", color = "black")) +
              theme(axis.text = element_text(size = 18, color = "black"), axis.title = element_text(size = 17, face = "bold")) +
              theme(axis.title = element_blank())+
              labs(fill = "Dimension", y = "Valeur de la composante / valeur max") +
              theme(legend.position = "bottom") +
              theme(text = element_text(family = "Roboto")) +
              coord_flip() 
            
            
            
          }
          
          
          ## Sinon, c'est un radar
        } else {
          
          
          
          
          ## Si percent
          if(input$choose_percent == "yes") {
            
            
            label_data$position = ifelse(label_data$score_ind > 90, yes = label_data$score_ind - 5, no = label_data$score_ind + 1)
            
            
            g <- ggplot(p, aes(x = indicateur, y = score_ind, tooltip = nom_complet_indic)) +
              geom_rect(xmin = -Inf, ymin = -20, xmax = Inf, ymax = Inf, fill = "white", color = "white") +
              geom_bar_interactive(aes(x = indicateur, y = 100, fill = dimension), alpha = 0.3, color = "black", position = position_dodge(width = 0.8), stat = "identity") +
              geom_col_interactive(color = "black", aes(fill = dimension)) +
              theme_bw() +
              geom_text(data = label_data, aes(x = id, y = position, label = paste0(round(score_ind), "%"), hjust = hjust), color = "black", fontface = "bold", alpha = 1, size = 5, angle = label_data$angle, inherit.aes = FALSE) +
              scale_fill_manual(limits = c("Agroécologique", "Socio-Territoriale", "Economique"), values = c("Agroécologique" = "#2e9c15", "Socio-Territoriale" = "#5077FE", "Economique" = "#FE962B")) +
              theme(
                axis.title = element_blank(),
                plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
                legend.text = element_text(size = 18),
                legend.title = element_text(size = 18),
                axis.text.y = element_blank(),
                axis.ticks.y = element_blank(),
                panel.grid.major.y = element_blank()
              ) +
              theme(axis.text = element_text(size = 18, color = "black", face = "bold")) +
              labs(fill = "Dimension") +
              theme(legend.position = "top") +
              theme(text = element_text(family = "Roboto")) +
              coord_polar()
            
            
            
          } else {
            
            label_data$position = ifelse(label_data$score_ind > 90, yes = label_data$value - 0.5, no = label_data$value + 0.5)
            
            
            g <- ggplot(p, aes(x = indicateur, y = value, tooltip = nom_complet_indic)) +
              geom_rect(xmin = -Inf, ymin = -20, xmax = Inf, ymax = Inf, fill = "white", color = "white") +
              geom_bar_interactive(aes(x = indicateur, y = valeur_max, fill = dimension), alpha = 0.3, color = "black", position = position_dodge(width = 0.8), stat = "identity") +
              geom_col_interactive(color = "black", aes(fill = dimension)) +
              theme_bw() +
              geom_text(data = label_data, aes(x = id, y = position, label = paste0(value, "/",valeur_max), hjust = hjust), color = "black", fontface = "bold", alpha = 1, size = 5, angle = label_data$angle, inherit.aes = FALSE) +
              scale_fill_manual(limits = c("Agroécologique", "Socio-Territoriale", "Economique"), values = c("Agroécologique" = "#2e9c15", "Socio-Territoriale" = "#5077FE", "Economique" = "#FE962B")) +
              theme(
                axis.title = element_blank(),
                plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
                legend.text = element_text(size = 18),
                legend.title = element_text(size = 18),
                axis.text.y = element_blank(),
                axis.ticks.y = element_blank(),
                panel.grid.major.y = element_blank()
              ) +
              theme(axis.text = element_text(size = 18, color = "black", face = "bold")) +
              labs(fill = "Dimension") +
              theme(legend.position = "top") +
              theme(text = element_text(family = "Roboto")) +
              coord_polar()
            
          }
          
          
          
          
        }
        
        
        girafe(ggobj = g, width_svg = 20, height_svg = 9, fonts = list(sans = "Roboto"))
        
      }
      
      
      
    })
    


    # Production des arbres éclairés et stockage dans le dossier temporaire, au format SVG
    MakeTrees(IDEAdata()) %>% exportIDEA(outdir = outdir, svg = TRUE)
    
    #### Définition des arbres éclairés à renvoyer
    output[["Robustesse"]] <- renderImage({
      
      inFile <- input$files
      
      if (is.null(inFile))
        return(box())
      
      val <- IDEAdata()$metadata$MTD_01
      v <- str_replace_all(val, " ", "_")
      
      outfile <- file.path(outdir,v,"Propriétés","Arbres_éclairés",paste0(v,"_","Robustesse.svg"))
      
      list(src = normalizePath(outfile),
           contentType = 'image/svg+xml',
           width = 1072/1.1,
           height = 767/1.1,
           alt = "Robustesse")
    }, deleteFile = TRUE)

    output[["Autonomie"]] <- renderImage({
      
      inFile <- input$files
      
      if (is.null(inFile))
        return(box())
      
      val <- IDEAdata()$metadata$MTD_01
      v <- str_replace_all(val, " ", "_")
      
      outfile <- file.path(outdir,v,"Propriétés","Arbres_éclairés",paste0(v,"_","Autonomie.svg"))
      
      list(src = normalizePath(outfile),
           contentType = 'image/svg+xml',
           width = 1073,
           height = 601,
           alt = "Autonomie")
    }, deleteFile = TRUE)

    output[["Capacité"]] <- renderImage({
      
      inFile <- input$files
      
      if (is.null(inFile))
        return(box())
      
      val <- IDEAdata()$metadata$MTD_01
      v <- str_replace_all(val, " ", "_")
      
      outfile <- file.path(outdir,v,"Propriétés","Arbres_éclairés",paste0(v,"_","Capacité productive et reproductive de biens et de services.svg"))
      
      
      list(src = normalizePath(outfile),
           contentType = 'image/svg+xml',
           width = 1193,
           height = 652,
           alt = "Capacité productive")
    }, deleteFile = TRUE)

    output[["Responsabilité"]] <- renderImage({
      
      inFile <- input$files
      
      if (is.null(inFile))
        return(box())
      
      val <- IDEAdata()$metadata$MTD_01
      v <- str_replace_all(val, " ", "_")
      
      outfile <- file.path(outdir,v,"Propriétés","Arbres_éclairés",paste0(v,"_","Responsabilité globale.svg"))
      
      list(src = normalizePath(outfile),
           contentType = 'image/svg+xml',
           width = 1063,
           height = 674,
           alt = "Responsabilité globale")
    }, deleteFile = TRUE)

    output[["Ancrage"]] <- renderImage({
      
      inFile <- input$files
      
      if (is.null(inFile))
        return(box())
      
      val <- IDEAdata()$metadata$MTD_01
      v <- str_replace_all(val, " ", "_")
      
      outfile <- file.path(outdir,v,"Propriétés","Arbres_éclairés",paste0(v,"_","Ancrage Territorial.svg"))
      
      
      list(src = normalizePath(outfile),
           contentType = 'image/svg+xml',
           width = 1072,
           height = 601,
           alt = "Ancrage territorial")
    }, deleteFile = TRUE)

    output[["Global"]] <- renderImage({
      
      inFile <- input$files
      
      if (is.null(inFile))
        return(box())
      
      val <- IDEAdata()$metadata$MTD_01
      v <- str_replace_all(val, " ", "_")
      
      outfile <- file.path(outdir,v,"Propriétés","Arbres_éclairés",paste0(v,"_","Global.svg"))
      
      list(src = normalizePath(outfile),
           contentType = 'image/svg+xml',
           width = 1158/1.2,
           height = 841/1.2,
           alt = "Global",
           class="center")
    }, deleteFile = TRUE)

    output[["Global_zoom"]] <- renderImage({
      
      inFile <- input$files
      
      if (is.null(inFile))
        return(box())
      
      val <- IDEAdata()$metadata$MTD_01
      v <- str_replace_all(val, " ", "_")
      
      outfile <- file.path(outdir,v,"Propriétés","Arbres_éclairés",paste0(v,"_","Global_zoom.svg"))
      
      list(src = normalizePath(outfile),
           contentType = 'image/svg+xml',
           width = 1244/1.4,
           height = 837/1.4,
           alt = "Global zoom",
           class="center")
    }, deleteFile = TRUE)
    

    # Boite contenant le widget de sélection de l'arbre éclairé à afficher
    output$select_tree <- renderUI({
      box(align = "center", width = 12,
          radioButtons("choose_tree", label = h4("Choisir la propriété :"), selected = "Global_zoom",
                                                    choices = c("Synthèse"="Global_zoom","Robustesse","Autonomie", "Ancrage Territorial" = "Ancrage", "Capacité Productive et reproductive de biens et de services" = "Capacité","Responsabilité Globale"="Responsabilité","Arbre complet"="Global"), inline = TRUE))
    })
    
    # Affichage des arbres éclairés
    output$tree_show <- renderUI({
      div(style="display:inline-block;width:100%;text-align: center;",
          imageOutput(input$choose_tree, width = "100%", height = "400px") %>% withSpinner(color="#0dc5c1")
      )
    })

    # Boite du téléchargement du rapport PDF
    output$box_rapport <- renderUI({
      box(width = 6, title = "Rapport automatisé",
          includeMarkdown("www/cap_rap.md"),
          br(),
          downloadButton("dl_report", "Télécharger le rapport", style = "width: 100%; padding:8px; font-size:120%"),
          footer = "Description : Ce rapport est un document PDF généré automatiquement, comptant 16 pages, compilant l'ensemble des métadonnées extraites dans le calculateur ainsi que l'ensemble des graphiques relatifs à l'approche par les dimensions ainsi que par les propriétés (dont les arbres éclairés).\nNB : La production du fichier peut nécessiter quelques secondes.")
    })
    
    # Boite du téléchargement de ZIP individuel
    output$box_zip1 <- renderUI({
      
      box(width = 6, title = "Archive compressée",
          includeMarkdown("www/cap_arc.md"),
          br(),
          downloadButton("dl_zip", "Télécharger l'archive",style = "font-size:120%; width:100%; padding:8px"),
          footer = "Description : Cette archive est un dossier compressé ZIP contenant l'ensemble des graphiques relatifs à l'approche par les dimensions ainsi que par les propriétés (dont les arbres éclairés).\nNB : La production du fichier peut nécessiter quelques secondes.")
      
      
    })

    # Définition des messages de validation / attention à l'import
    if(IDEAdata()$metadata$MTD_00 %in% c(NA,"0"))  {
      
      sendSweetAlert(
        session = session,
        title = "Attention !",
        text = p(HTML("<p style='text-align:justify;'> La version du calculateur inséré est antérieure à la version 4.2.\n Toutes les métadonnées n'ont pas pu être extraites.</p>")),
        type = "warning"
      )
      
    } else {
      sendSweetAlert(
        session = session,
        title = "Succès !",
        text = "Le calculateur a été correctement importé.",
        type = "success"
      )
    }
    
    
    
  })


  ###### UI TRIGGER ANALYSE DE GROUPE #########


  observeEvent(input$dir,{
    
    # Petit message d'aide pour la navigation dans les menus
    output$helper2 <- renderUI({
      HTML("<p style='color:blue'> NB : Pour aller plus loin dans le détail des indicateurs et pour exporter ces résultats, vous pouvez naviguer dans le menu d'en-tête 'Analyse de groupe'.</p>")
    }) 
    
   
    
    
    # Boîte de synthèse de l'analyse de groupe
    output$carac_grp <- renderUI({
      
      withProgress(message = "Traitement de l'analyse de groupe...",detail = "Le processus peut nécessiter quelques minutes", value = 0.5,{
        
        nb_exploit <- nrow(IDEAcollectiveData()$metadata)
        mean_ae <- IDEAcollectiveData()$dataset %>% filter(dimension == "Agroécologique") %>% pull(dimension_value) %>% mean() %>% round()
        mean_st <- IDEAcollectiveData()$dataset %>% filter(dimension == "Socio-Territoriale") %>% pull(dimension_value) %>% mean() %>% round()
        mean_ec <- IDEAcollectiveData()$dataset %>% filter(dimension == "Economique") %>% pull(dimension_value) %>% mean() %>% round()
        
        box(title = "Caractéristiques du groupe", width = 10,collapsible = FALSE,
            valueBox(nb_exploit, "Nombre d'exploitations agricoles", width = 3, color = "purple"),
            valueBox(paste0(mean_ae,"/100"), "Score moyen Dim. Agroécologique", icon = icon("leaf"), color = "green", width = 3),
            valueBox(paste0(mean_st,"/100"), "Score moyen Dim. Socio-Territoriale", icon = icon("handshake"), color = "blue", width = 3),
            valueBox(paste0(mean_ec,"/100"), "Score moyen Dim. Economique", icon = icon("euro-sign"), color = "orange", width = 3))


      })
      
    })
  
    ## Production de la table colorée des propriétés dans l'application
    output$table_prop <- DT::renderDataTable({
      
      df <- IDEAcollectiveData()$nodes$Global %>%
        gather(key = indicateur, value = resultat, -id_exploit) %>%
        mutate(indicateur = replace_indicateur(indicateur)) %>%
        inner_join(label_nodes, by = c("indicateur" = "code_indicateur")) %>%
        mutate(resultat = factor(resultat, levels = c("très favorable", "favorable", "intermédiaire", "défavorable", "très défavorable", "NC"))) %>%
        mutate(nom_indicateur = ifelse(nom_indicateur == "Capacité productive et reproductive de biens et de services", yes = "Capacité productive et \n reproductive de biens et de \n services", no = nom_indicateur)) %>%
        mutate(num_indic = parse_number(indicateur)) %>%
        arrange(dim, num_indic) %>%
        mutate(indicateur = factor(indicateur, levels = unique(indicateur))) %>%
        mutate(level = case_when(
          level == "indicateur" ~ "Indicateur",
          level == "propriete" ~ "Propriété"
        )) %>% 
        filter(level == "Propriété") %>% 
        select(id_exploit,nom_indicateur,resultat) %>% 
        spread(key = nom_indicateur, value = resultat)
      
      rown <- df$id_exploit
      df <- df %>% select(-id_exploit)
      
      
      datatable(df, rownames = rown) %>% 
        formatStyle('Robustesse', backgroundColor = styleEqual(c("favorable", "défavorable", "intermédiaire","très défavorable", "très favorable"), c('#1CDA53', '#FF6348',"#FFA300","#FF0000","#0D8A00"))) %>% 
        formatStyle('Autonomie', backgroundColor = styleEqual(c("favorable", "défavorable", "intermédiaire","très défavorable", "très favorable"), c('#1CDA53', '#FF6348',"#FFA300","#FF0000","#0D8A00"))) %>% 
        formatStyle('Ancrage territorial', backgroundColor = styleEqual(c("favorable", "défavorable", "intermédiaire","très défavorable", "très favorable"), c('#1CDA53', '#FF6348',"#FFA300","#FF0000","#0D8A00"))) %>% 
        formatStyle('Capacité productive et \n reproductive de biens et de \n services', backgroundColor = styleEqual(c("favorable", "défavorable", "intermédiaire","très défavorable", "très favorable"), c('#1CDA53', '#FF6348',"#FFA300","#FF0000","#0D8A00"))) %>% 
        formatStyle('Responsabilité globale', backgroundColor = styleEqual(c("favorable", "défavorable", "intermédiaire","très défavorable", "très favorable"), c('#1CDA53', '#FF6348',"#FFA300","#FF0000","#0D8A00"))) %>% 
        formatStyle(c("Robustesse","Autonomie", "Ancrage territorial", "Capacité productive et \n reproductive de biens et de \n services", "Responsabilité globale"), border = '1px solid #ddd')
      
    })
    
    
    
    # Production d'une heatmap
    output$heatmap <- renderPlot({
      
      var <- metaIDEA(IDEAcollectiveData())
      
      var$metaProp + coord_flip()
      
    })
    
    
    
    
    # Production du graphe interactif, soit un boxplot soit un diagramme en barres empilé
    output$boxpl <- renderGirafe({
      
      if(input$xcol == "box") {
        
        dim <- IDEAcollectiveData()$dataset %>% distinct(id_exploit, dimension, dimension_value)
        
        p <- ggplot(dim, aes(x = dimension, y = dimension_value, fill = dimension)) +
          geom_boxplot(outlier.size = 0) +
          geom_jitter_interactive(aes(tooltip = id_exploit),shape = 21, color = "black", size = 4, position=position_jitter(width = 0.2, height = 0)) +
          scale_fill_manual(values = c("Agroécologique" = "#2e9c15", "Socio-Territoriale" = "#469FF9", "Economique" = "#FE962B"), drop = FALSE) +
          theme_bw() +
          ylim(0,100)+
          labs(fill = "Dimension", y = "Score de la dimension") +
          theme(axis.title.x = element_blank())+
          theme(
            axis.title = element_text(size = 17),
            legend.text = element_text(size = 13),
            legend.title = element_text(size = 15),
            strip.text = element_text(size = 9, face = "bold")
          ) +
          theme(legend.position = "bottom") +
          theme(axis.text = element_text(size = 15, color = "black")) +
          theme(strip.background = element_rect(fill = "white", color = "black")) 
        
        girafe(ggobj = p, width_svg = 10, height_svg = 7)
        
        
      } else {
        
        dim <- IDEAcollectiveData()$dataset %>% distinct(id_exploit, dimension, dimension_value)
        
        dim2 <- bind_rows(dim %>% mutate(dimension_value = 100 - dimension_value) %>% mutate(alpha = "a"), dim %>% mutate(alpha = "b")) %>%
          arrange(id_exploit, dimension) %>%
          mutate(label = ifelse(alpha == "a", yes = "", no = paste0(dimension_value, "/100")))
        
        
        p <- ggplot(dim2, aes(x = id_exploit, y = dimension_value, label = label, fill = dimension, alpha = alpha, tooltip = id_exploit)) +
          scale_alpha_manual(values = c(0.6, 1)) +
          guides(alpha = FALSE) +
          geom_col_interactive(color = "black") +
          geom_text(aes(x = id_exploit, y = dimension_value, label = label), position = position_stack(vjust = 0.5)) +
          scale_fill_manual(values = c("Agroécologique" = "#2e9c15", "Socio-Territoriale" = "#469FF9", "Economique" = "#FE962B"), drop = FALSE) +
          theme_bw() +
          ylim(0, 300) +
          labs(x = "Exploitation", y = "Score", fill = "Dimension") +
          theme(
            axis.title = element_text(size = 17),
            legend.text = element_text(size = 13),
            legend.title = element_text(size = 15),
            strip.text = element_text(size = 9, face = "bold")
          ) +
          theme(axis.text = element_text(size = 13, color = "black")) +
          theme(strip.background = element_rect(fill = "white", color = "black")) +
          theme(legend.position = "bottom") +
          coord_flip()
        
        girafe(ggobj = p, width_svg = 10, height_svg = 7)
        
      }
      
      
    })
    
    
    
    
    # production de la table avec les statistiques descriptives
    output$table1 <- renderTable({
      IDEAcollectiveData()$dataset %>% 
        group_by(dimension) %>% 
        summarise(
          `Min.`= min(dimension_value),
          P25 = quantile(dimension_value,0.25),
          Médiane = quantile(dimension_value,0.5),
          Moyenne = mean(dimension_value),
          P75 = quantile(dimension_value,0.75),
          `Max.` = max(dimension_value)
        ) %>% 
        rename("Dimension"="dimension") 
    }, striped = TRUE, width = "100%")
  


    # Boite de synthèse des dimensions
    output$group_dim <- renderUI({
      box(width = 6,title = "Synthèse de l'approche par les dimensions",collapsible = FALSE,align = "center",
          radioButtons(inputId = "xcol",label = "Choisir la représentation",choices = c("Distribution" = "box",
                                                                                        "Barres" = "col"), selected = "box", inline = TRUE, width = "100%"),
          br(),
          girafeOutput("boxpl") %>% withSpinner(color="#0dc5c1"),
          hr(),
          tableOutput("table1"),
          footer = HTML("<center>Note : Pour le graphique de distribution, le nom de l'exploitation s'affiche au survol du point correspondant</center>"))
    }) 
    
    
    # Boite de synthèse des propriétés
    output$group_prop <- renderUI({
      box(width = 6,title = "Synthèse de l'approche par les propriétés",collapsible = FALSE, align = "center",
          tabsetPanel(
            tabPanel("Table de synthèse",
                     DT::dataTableOutput("table_prop") %>% withSpinner(color="#0dc5c1")),
            tabPanel("Version graphique",
                     plotOutput("heatmap", width = "80%") %>% withSpinner(color="#0dc5c1")
            )
          ))
      
    })


   # Boîte de téléchargement du fichier excel pour l'analyse de groupe 
   output$box_excel <- renderUI({
      box(width = 6, title = "Fichier excel",
          includeMarkdown("www/cap_excel.md"),
          br(),
          downloadButton("dl_excel", "Télécharger le fichier .xlsx", style = "font-size:120%; width:100%; padding:8px"),
          footer = "Description : Ce fichier unique compile l'ensemble des données du collectif inséré ainsi que les statistiques descriptives permettant de décrire ce collectif. Pour les onglets concernant l'évaluation par les propriétés, les cellules sont automatiquement colorées en fonction de la modalité selon la grille de couleur élaborée par le CS IDEA.")
    })
    
   # Boîte de téléchargement de l'archive zip pour l'analyse de groupe (Affiché temporairement en construction)
    output$box_zip2 <- renderUI({
      box(width = 6, title = "Archive compressée",
          includeMarkdown("www/cap_arc2.md"),
          br(),
          HTML("<center> <b> Module en cours de construction. </b> </center>"),
          # downloadButton("dl_zip2", "Télécharger l'archive", style = "width: 100%; padding:8px; font-size:120%"),
          footer = "Description : Cette archive est un dossier compressé ZIP contenant l'ensemble des graphiques relatifs à l'approche par les dimensions ainsi que par les propriétés (dont les arbres éclairés). Ce dossier est composé d'un sous-dossier pour chaque exploitation qui contient les figures relatives à cette exploitation.\nNB : L'hébergement serveur actuel ne semble pas supporter le téléchargement d'une archive contenant plus de 5 exploitations.")
    })
  
    })

  ###### DEFINITION DES TELECHARGEMENTS (downloadHandler) #######


  # 1. Diagramme composantes polarisé
  output$dl_pol <- downloadHandler(
    
    filename = function() {
      v <- IDEAdata()$metadata$MTD_01 %>%  str_replace_all(" ", "_")
      paste0("Diagramme_Polaire_",v, ".png")
    },
    
    content = function(fname) {
      
      withProgress(message = "Production du graphique en cours...",detail = "Merci de patienter.",value = 0.1,{
    
        graph <- PolarComponent(IDEAdata(),dir = outdir)
        
        ggsave(graph[[1]], filename = fname, dpi = "retina", width = 8, height = 8)
        
        incProgress(0.95)
      })
      
    }
  )


  # 2. Rapport PDF
  output$dl_report <- downloadHandler(
    # For PDF output, change this to "report.pdf"
    
    filename = function() {
      v <- IDEAdata()$metadata$MTD_01 %>%  str_replace_all(" ", "_")
      paste0("Rapport_IDEA4_",v, ".pdf")
    },
    
    content = function(file) {
      
      
      withProgress(message = "Votre rapport est en cours de préparation...",detail = "Merci de patienter quelques instants", value = 0.5,{
        
        inFile <- input$files
        
        tempReport <- file.path(tempdir(), "rapport_individuel.Rmd")
        template <- "www/rapport_individuel.Rmd"
        
        tempStyle <- file.path(tempdir(), "bandeau.png")
        style_folder <- "www/bandeau.png"
        
        file.copy(template, tempReport, overwrite = TRUE)
        file.copy(style_folder, tempStyle, overwrite = TRUE)
        
        
        # Définition des paramètres pour le rendu
        params <- list(data = IDEAdata(),
                       outdir = outdir,
                       anon = FALSE)
        
        # Rendu du document dans un sous-environnement isolé
        render(tempReport, output_file = file,
                          params = params,
                          envir = new.env(parent = globalenv())
        )
        incProgress(0.8)
      })
      
    }
  )
  
  
  
  # 3. Archive ZIP analyse individuelle
  output$dl_zip <- downloadHandler(
    
    filename = function() {
      v <- IDEAdata()$metadata$MTD_01 %>%  str_replace_all(" ", "_")
      paste0("Figures_",v, ".zip")
    },
    
    content = function(fname) {
      
      withProgress(message = "Votre archive est en cours de préparation...",detail = "Merci de patienter quelques instants", value = 0.1,{
        
        
        ## Production des figures nécessaires à l'archive
        v <- IDEAdata()$metadata$MTD_01 %>%  str_replace_all(" ", "_")
        
        incProgress(0.3, detail = "Production des arbres éclairés...")
        
        MakeTrees(IDEAdata()) %>% exportIDEA(outdir = outdir)
        
        incProgress(0.5, detail = "Production des graphiques dimensions...")
        
        dimensionsPlots(IDEAdata()) %>% exportIDEA(outdir = outdir)
        
        incProgress(0.7, detail = "Production des graphiques radar...")
        
        radarPlots(IDEAdata()) %>% exportIDEA(outdir = outdir)
      


        
        
        ## Définition du chemin des fichiers à archiver
        current_dir <- getwd()
        setwd(outdir)
        
        fs <- file.path(v,list.files(file.path(outdir,v), recursive=TRUE))
        
        ## Ces trois fichiers sont générés en plus de leur version "correctement nommée" pour la production du rapport,
        ## qui est codé en LaTeX et a besoin de chemin de fichiers sans accents ni espaces...
        ## Il n'ont pas à être dans l'archive zip
        fs <- setdiff(fs,fs[str_detect(fs,"Ancrage.pdf")])
        fs <- setdiff(fs,fs[str_detect(fs,"CAP.pdf")])
        fs <- setdiff(fs,fs[str_detect(fs,"RESP.pdf")])
        
        # Export du zip
        zip(zipfile = fname, files = fs)
        setwd(current_dir)
        
        incProgress(0.9)
      })
      
    }
    ,contentType = "application/zip"
  )
  

  # 4. Classeur excel
  output$dl_excel <- downloadHandler(
    
    filename = function() {
      paste0("Analyse_Groupe_",format(Sys.time(), '%d_%m_%Y_%H_%M_%S'), ".xlsx")
    },
    
    content = function(fname) {
      
      withProgress(message = "Votre fichier est en cours de production...",detail = "Merci de patienter quelques instants", value = 0.5,{
      
      wb <- createWorkbook()
      FStyle <- createStyle(fontColour = "#000000", bgFill = "#1CDA53")
      TFStyle <- createStyle(fontColour = "#000000", bgFill = "#0D8A00")
      IStyle <- createStyle(fontColour = "#000000", bgFill = "#FFA300")
      DStyle <- createStyle(fontColour = "#000000", bgFill = "#FF6348")
      TDStyle <- createStyle(fontColour = "#000000", bgFill = "#FF0000")
      NCStyle <- createStyle(fontColour = "#000000", bgFill = "#cecece")
    
      
      
      ## Résumé
      addWorksheet(wb, "Synthèse dimension")
      t1 <- IDEAcollectiveData()$dataset %>% 
        group_by(dimension) %>% 
        summarise(
          `Min.`= min(dimension_value),
          P25 = quantile(dimension_value,0.25),
          Médiane = quantile(dimension_value,0.5),
          Moyenne = mean(dimension_value),
          P75 = quantile(dimension_value,0.75),
          `Max.` = max(dimension_value)
        ) %>% 
        rename("Dimension"="dimension") 
      
      writeData(wb, "Synthèse dimension",t1, borders = "all")
      
      
      setColWidths(wb, "Synthèse dimension", cols = 1:150, widths = "auto")
      
      
      ## Dimensions
      addWorksheet(wb, "Détail dimensions")
      
      
      indicateurs <- IDEAcollectiveData()$dataset %>%
        distinct(id_exploit, indicateur, value) %>%
        rowwise() %>%
        mutate(no = parse_number(indicateur), letter = str_split(indicateur, "")[[1]][1]) %>%
        ungroup() %>%
        arrange(letter, no) %>%
        mutate(indicateur = factor(indicateur, levels = unique(indicateur))) %>%
        select(-no, -letter) %>%
        spread(key = indicateur, value = value)
      
      composantes <- IDEAcollectiveData()$dataset %>%
        rowwise() %>%
        mutate(composante = paste0("Composante ", composante)) %>%
        ungroup() %>%
        distinct(id_exploit, composante, composante_value) %>%
        spread(key = composante, value = composante_value)
      
      dimensions <- IDEAcollectiveData()$dataset %>%
        rowwise() %>%
        mutate(dimension = paste0("Dimension ", dimension)) %>%
        ungroup() %>%
        distinct(id_exploit, dimension, dimension_value) %>%
        spread(key = dimension, value = dimension_value)
      
      approche_dimensions <- inner_join(indicateurs, composantes, by = "id_exploit") %>%
        inner_join(dimensions, by = "id_exploit") %>%
        rowwise() %>%
        mutate(no = str_split(id_exploit, "-")[[1]][2] %>% as.numeric(), org = str_split(id_exploit, "-")[[1]][1]) %>%
        ungroup() %>%
        arrange(org, no) %>%
        select(-org, -no) %>% 
        rename("Exploitation"="id_exploit")
      



      empty <- approche_dimensions %>% slice(1) 
      empty[1,] = NA
      
      
      quant1 <- function(x){
        
        
        if(is.character(x)) {return(x[1])}
        
        return(quantile(x, probs = 0.25, na.rm=TRUE) %>% round(2))
        
      }
      
      quant2 <- function(x){
        
        
        if(is.character(x)) {return(x[1])}
        
        return(quantile(x, probs = 0.75, na.rm=TRUE) %>% round(2))
        
      }
      

      
      iris %>% summarise(across(-Species,~round(.x)))
      
      # Production des statistiques supplémentaires
      min_ea <- approche_dimensions %>% summarise(across(-Exploitation,~min(.x,na.rm=TRUE))) %>% summarise_all(round,2)
      min_ea <- cbind(data.frame("Exploitation" = "Valeur minimale"),min_ea)

      Q1_ea <- approche_dimensions %>% summarise(across(-Exploitation,~quantile(.x,0.25,na.rm=TRUE))) %>% summarise_all(round,2)
      Q1_ea <- cbind(data.frame("Exploitation" = "Premier quartile"),Q1_ea)

      mean_ea <- approche_dimensions %>% summarise(across(-Exploitation,~mean(.x,na.rm=TRUE))) %>% summarise_all(round,2)
      mean_ea <- cbind(data.frame("Exploitation" = "Moyenne générale"),mean_ea)
      
      med_ea <- approche_dimensions %>% summarise(across(-Exploitation,~median(.x,na.rm=TRUE))) %>% summarise_all(round,2)
      med_ea <- cbind(data.frame("Exploitation" = "Médiane générale"),med_ea)

      sd_ea <- approche_dimensions %>% summarise(across(-Exploitation,~sd(.x,na.rm=TRUE))) %>% summarise_all(round,2)
      sd_ea <- cbind(data.frame("Exploitation" = "Ecart-type"),sd_ea)
      
      Q3_ea <- approche_dimensions %>% summarise(across(-Exploitation,~quantile(.x,0.75,na.rm=TRUE))) %>% summarise_all(round,2)
      Q3_ea <- cbind(data.frame("Exploitation" = "Troisième quartile"),Q3_ea)

      max_ea <- approche_dimensions %>% summarise(across(-Exploitation,~max(.x,na.rm=TRUE))) %>% summarise_all(round,2)
      max_ea <- cbind(data.frame("Exploitation" = "Valeur maximale"),max_ea)





      writeData(wb, "Détail dimensions",bind_rows(approche_dimensions,empty,min_ea,Q1_ea,mean_ea,med_ea,sd_ea,Q3_ea,max_ea), borders = "all")
      
      
      setColWidths(wb, "Détail dimensions", cols = 1:150, widths = "auto")
      
      
      
      ## Propriétés terminales
      addWorksheet(wb, "Synthèse propriétés")
      
      
      df <- IDEAcollectiveData()$nodes$Global %>%
        gather(key = indicateur, value = resultat, -id_exploit) %>%
        mutate(indicateur = replace_indicateur(indicateur)) %>%
        inner_join(label_nodes, by = c("indicateur" = "code_indicateur")) %>%
        mutate(resultat = factor(resultat, levels = c("très favorable", "favorable", "intermédiaire", "défavorable", "très défavorable", "NC"))) %>%
        mutate(nom_indicateur = ifelse(nom_indicateur == "Capacité productive et reproductive de biens et de services", yes = "Capacité productive et \n reproductive de biens et de \n services", no = nom_indicateur)) %>%
        mutate(num_indic = parse_number(indicateur)) %>%
        arrange(dim, num_indic) %>%
        mutate(indicateur = factor(indicateur, levels = unique(indicateur))) %>%
        mutate(level = case_when(
          level == "indicateur" ~ "Indicateur",
          level == "propriete" ~ "Propriété"
        )) %>% 
        filter(level == "Propriété") %>% 
        select(Exploitation = id_exploit,nom_indicateur,resultat) %>% 
        spread(key = nom_indicateur, value = resultat)
      
      
      empty <- df %>% slice(1) 
      empty[1,] = NA
      
      
      
      to_add <- df %>% 
        gather(key = param, value = value, -Exploitation) %>% 
        group_by(param) %>% 
        count(value) %>% 
        spread(key = param, value = n) %>% 
        rename("Exploitation" = "value") %>% 
        rowwise() %>% 
        mutate(Exploitation = paste0("Nombre de ",Exploitation," :")) %>% 
        ungroup() %>% 
        summarise_all(as.character) %>% 
        summarise_all(replace_na,replace = 0)
      
      
      # to_add_row <- df %>%
      #   gather(key = param, value = value, -Exploitation) %>%
      #   group_by(Exploitation) %>%
      #   count(value) %>% 
      #   rowwise() %>% 
      #   mutate(value = paste0("Nombre de ",value)) %>% 
      #   ungroup() %>% 
      #   spread(key = value, value = n) %>% 
      #   summarise_all(as.character) %>% 
      #   summarise_all(replace_na,replace = 0) %>% 
      #   select(-Exploitation)
      
      
      
      
      # Propriétés --------------------------------------------------------------
      
      
      writeData(wb, "Synthèse propriétés",df %>% bind_rows(empty,to_add), borders = "all")
      
      
      conditionalFormatting(wb, "Synthèse propriétés", cols = 1:150, rows = 1:300, type = "contains", rule = "favorable",style = FStyle)
      conditionalFormatting(wb, "Synthèse propriétés", cols = 1:150, rows = 1:300, type = "contains", rule = "défavorable",style = DStyle)
      conditionalFormatting(wb, "Synthèse propriétés", cols = 1:150, rows = 1:300, type = "contains", rule = "intermédiaire",style = IStyle)
      conditionalFormatting(wb, "Synthèse propriétés", cols = 1:150, rows = 1:300, type = "contains", rule = "très favorable",style = TFStyle)
      conditionalFormatting(wb, "Synthèse propriétés", cols = 1:150, rows = 1:300, type = "contains", rule = "très défavorable",style = TDStyle)
      conditionalFormatting(wb, "Synthèse propriétés", cols = 1:150, rows = 1:300, type = "contains", rule = "NC",style = NCStyle)
      
      setColWidths(wb, "Synthèse propriétés", cols = 1:150, widths = "auto")
      
      
      
      
      ## Boucle pour les propriétés globales
      for (i in names(IDEAcollectiveData()$nodes)){
        

    
        onglet <- case_when(i == "Robustesse" ~ "Robustesse",
                            i == "Capacité" ~ "Capacité productive",
                            i == "Autonomie" ~ "Autonomie",
                            i == "Responsabilité" ~ "Responsabilité globale",
                            i == "Ancrage" ~ "Ancrage territorial",
                            i == "Global" ~ "Total propriétés")
        
      
        
        
        addWorksheet(wb, onglet)
        
        df <- IDEAcollectiveData()$nodes[[i]]
        
        names(df)[1] <- "Exploitation"
        
        empty <- df %>% slice(1) 
        empty[1,] = NA
        
        
        to_add <- df %>% 
          gather(key = param, value = value, -Exploitation) %>% 
          group_by(param) %>% 
          count(value) %>% 
          spread(key = param, value = n) %>% 
          rename("Exploitation" = "value") %>% 
          rowwise() %>% 
          mutate(Exploitation = paste0("Nombre de ",Exploitation," :")) %>% 
          ungroup() %>% 
          summarise_all(as.character)%>% 
          summarise_all(replace_na,replace = 0)
        
        
        
        # to_add_row <- df %>%
        #   gather(key = param, value = value, -Exploitation) %>%
        #   group_by(Exploitation) %>%
        #   count(value) %>% 
        #   rowwise() %>% 
        #   mutate(value = paste0("Nombre de ",value)) %>% 
        #   ungroup() %>% 
        #   spread(key = value, value = n) %>% 
        #   summarise_all(as.character) %>% 
        #   summarise_all(replace_na,replace = 0) %>% 
        #   select(-Exploitation)
        
        
        
        writeData(wb, onglet,df %>% bind_rows(empty,to_add), borders = "all")
        
        conditionalFormatting(wb, onglet, cols = 1:150, rows = 1:300, type = "contains", rule = "favorable",style = FStyle)
        conditionalFormatting(wb, onglet, cols = 1:150, rows = 1:300, type = "contains", rule = "défavorable",style = DStyle)
        conditionalFormatting(wb, onglet, cols = 1:150, rows = 1:300, type = "contains", rule = "intermédiaire",style = IStyle)
        conditionalFormatting(wb, onglet, cols = 1:150, rows = 1:300, type = "contains", rule = "très favorable",style = TFStyle)
        conditionalFormatting(wb, onglet, cols = 1:150, rows = 1:300, type = "contains", rule = "très défavorable",style = TDStyle)
        conditionalFormatting(wb, onglet, cols = 1:150, rows = 1:300, type = "contains", rule = "NC",style = NCStyle)
        
        
        setColWidths(wb, onglet, cols = 1:150, widths = "auto")
        
      }
      
      saveWorkbook(wb, fname, TRUE)
    
      })
        
    }
    
    
  )
  

  

  
  
  
  # 5. Archive ZIP pour l'analyse de groupe
  output$dl_zip2 <- downloadHandler(
    
    filename = function() {
      paste0("Figures_Groupe_",format(Sys.time(), '%d_%m_%Y_%H_%M_%S'), ".zip")
    },
    
    content = function(fname) {
      
      withProgress(message = "Votre archive est en cours de préparation...",detail = "Temps estimé : 20s par exploitation",value = 0.1,{
        
        
        ## Production des figures nécessaires à l'archive
        v <- IDEAcollectiveData()$metadata$MTD_01 %>%  str_replace_all(" ", "_")
        
        incProgress(0.3, detail = "Production des arbres éclairés...")
        
        MakeTrees(IDEAcollectiveData()) %>% exportIDEA(outdir = outdir)
        
        incProgress(0.5, detail = "Production des graphiques dimensions...")
        
        dimensionsPlots(IDEAcollectiveData()) %>% exportIDEA(outdir = outdir)
        
        incProgress(0.7, detail = "Production des graphiques radar...")
        
        radarPlots(IDEAcollectiveData()) %>% exportIDEA(outdir = outdir)
        
        
        if(length(IDEAcollectiveData()$metadata$MTD_01) > 2) {
          incProgress(0.8, detail = "Production des graphiques collectifs...")
          metaIDEA(IDEAcollectiveData()) %>% exportIDEA(outdir = outdir)
        }
        
        
        
        ## Définition du chemin des fichiers à archiver
        current_dir <- getwd()
        setwd(outdir)
        
        fs <- file.path(list.files(file.path(outdir,v), recursive=TRUE, full.names = TRUE))
        
        # On retire la racine du chemin
        fs <- str_remove_all(fs,paste0(outdir,"/"))
        
        ## Ces trois fichiers sont générés en plus de leur version "correctement nommée" pour la production du rapport,
        ## qui est codé en LaTeX et a besoin de chemin de fichiers sans accents ni espaces...
        ## Il n'ont pas à être dans l'archive zip
        fs <- setdiff(fs,fs[str_detect(fs,"Ancrage.pdf")])
        fs <- setdiff(fs,fs[str_detect(fs,"CAP.pdf")])
        fs <- setdiff(fs,fs[str_detect(fs,"RESP.pdf")])
        
        # Export du zip
        zip(zipfile = fname, files = fs)
        setwd(current_dir)
        
        incProgress(0.95)
      })
      
    }
    ,contentType = "application/zip"
  )
  
  
  
}
